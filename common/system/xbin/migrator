#!/system/bin/sh
# Migrator Wizard
# Copyright (C) 2018-2019, VR25 @ xda-developers
# License: GPL V3+


[ -d /sbin/.magisk/busybox ] \
  && PATH=/sbin/.magisk/busybox:$PATH \
  || PATH=/sbin/.core/busybox:$PATH

log=/data/media/adk/logs/wizard.log


umask 0
set -euo pipefail


# log
if [ -f /data/media/adk/verbose ]; then
  mkdir -p ${log%/*}
  [ -f $log ] && grep -q .. $log && mv $log $log.old
  set -x 2>>$log
  trap 'rm /data/media/adk/verbose 2>/dev/null' EXIT
fi


# set modPath
modPath=/sbin/.magisk/img/adk
[ -f $modPath/module.prop ] || modPath=/sbin/.core/img/adk
[ -f $modPath/module.prop ] || { echo -e "\n(!) modPath not found\n"; exit 1; }
. $modPath/core.sh # load core


# Remove backups of uninstalled apps
rm_uninstalled() {
  local pkg=""
  bkps_path
  if ls -p $appDataBkps 2>/dev/null | grep -q /; then
    mk_list not_installed
    if grep -q '[a-z]' $tmpDir/pkg_list0; then
      regex_prompt
      if grep -q '[a-z]' $tmpDir/pkg_list; then
        echo -e "\n(i) Removing.."
        for pkg in $(cat $tmpDir/pkg_list); do
          echo "- $pkg"
          rm -rf $apkBkps/$pkg.apk $appDataBkps/$pkg 2>/dev/null
        done
        echo
      else
        no_match rm_uninstalled
      fi
    else
      echo -e "(i) Nothing to remove\n"
    fi
    exit_or_not
  else
    missing_bkp
  fi
}


# generic incremental backup utility
rsync_util() {
  local a=""
  echo "(i) Use \$i for internal storage and \$e for external media (largest partition), instead of writing full paths. Example: rsync -hrtuv --inplace --progress --stats --del \$i/ \$e/full_internal_bkp".
  echo -n "\nrsync -hrtuv --inplace --progress --stats "
  read a
  echo
  while :; do
    eval $rsync -hrtuv --inplace --progress --stats $a
    echo
    echo "(i) Next incremental backup in $bkpFreq hours"
    echo "- Press CTRL+C (Vol. Down + C) to cancel the schedule and exit."
    echo -n "- You may minimize this window."
    sleep $((bkpFreq * 3600))
    echo
    echo
  done
}


restore_apps() {
  local pkg=""
  bkps_path
  if ls $apkBkps 2>/dev/null | grep -q .apk; then
    : >$tmpDir/pkg_list0
    for pkg in $(ls -1 $apkBkps); do
      echo "- $pkg"
      echo $pkg >>$tmpDir/pkg_list0
    done
    regex_prompt
    if grep -q '[a-z]' $tmpDir/pkg_list; then
      echo -e "\n[Re]installing.."
      pkg=""
      for pkg in $(cat $tmpDir/pkg_list); do
        echo -n "- $pkg"
        if grep -q "${pkg%.apk}" "$pkgList"; then
          pm install -r "$apkBkps/$pkg" 1>/dev/null || :
        else
          pm install "$apkBkps/$pkg" 1>/dev/null || :
        fi
        echo
      done
      post_restore apps apps
    else
      no_match restore_apps
    fi
  else
    missing_bkp
  fi
}


restore_data() {
  bkps_path
  if ls -p $appDataBkps 2>/dev/null | grep -q /; then
    mk_list installed
    regex_prompt
    if grep -q '[a-z]' $tmpDir/pkg_list; then
      restore data data
    else
      no_match restore_data
    fi
  else
    missing_bkp
  fi
}


restore_apps_and_data() {
  local o="" pkg=""
  bkps_path
  if ls $appDataBkps 2>/dev/null | grep -q .; then
    echo -n "Filter out already installed apps? (Y/n) "
    read o
    reset
    echo
    echo $o | grep -iq n && mk_list all \
      || mk_list not_installed
    if ! grep -q '[a-z]' $tmpDir/pkg_list0; then
      echo -e "(i) Nothing left to restore\n"
      o=""
      select o in Exit "Main menu" \
        "Restore apps (replace)" \
        "Restore data (overwrite)"
      do
        case $o in
          Exit) echo; exit 0;;
          "Main menu") wizard; break;;
          "Restore apps (replace)") reset; echo; restore_apps; break;;
          "Restore data (overwrite)") reset; echo; restore_data; break;;
        esac
      done
    fi
    set -u
    regex_prompt
    if grep -q '[a-z]' $tmpDir/pkg_list; then
      restore apps+data apps_and_data
    else
      no_match restore_apps_and_data
    fi
  else
    missing_bkp
  fi
}


wizard() {
  local o=""
  find_sdcard nowait
  reset
  cat <<ACTIONS

Migrator Wizard

Restore
  1) Apps (replace)
  2) Data (overwrite)
  3) Apps+data
Utilities
  4) Manual apps+data backup
  5) Debugging info
  6) rsync -hrtuv --inplace --progress --stats \$@
  7) Remove select backups of uninstalled and/or excluded apps
---
  0) Exit

ACTIONS

  echo -n "(i) Choose an option.. "
  read o

  case $o in
    0) echo -e "\n  Goodbye.\n"; exit 0;;
    1) reset; echo; restore_apps;;
    2) reset; echo; restore_data;;
    3) reset; echo; restore_apps_and_data;;
    4) reset; echo; onboot ondemand;;
    5) reset; echo; debug_info;;
    6) reset; echo; rsync_util;;
    7) reset; echo; rm_uninstalled;;
    *) echo; echo -n "  (!) Invalid choice!"; sleep 2; wizard;;
  esac
}


debug_info() {
  getprop | grep -Ei 'product|version'
  echo
  set
  echo
  echo "SELinux status: $(getenforce 2>/dev/null || sestatus 2>/dev/null)" \
    | sed 's/En/en/;s/Pe/pe/'
  echo
  exit_or_not
}


no_match() {
  local o=""
  echo -e "\n(!) No match!\n"
  select o in Exit Retry "Main menu"; do
    case $o in
      Exit) echo; exit 0;;
      Retry) reset; $1; break;;
      "Main menu") wizard; break;;
    esac
  done
}


missing_bkp() {
    echo -e "\n(!) Backup folder not found or empty!\n"
    exit_or_not
}


post_restore() {
  local o=""
  echo
  echo "Done. Now what?"
  select o in Exit "Main menu" "Restore more $1"; do
    case $o in
      Exit) echo; exit 0;;
      "Main menu") wizard; break;;
      "Restore more $1") reset; restore_$2; break;;
    esac
  done
}


regex_prompt() {
  local i=""
  : >$tmpDir/pkg_list
  echo
  echo -n "(i) Type egrep pattern(s) (e.g., sp.*fy or duk|faceb|whats. A dot matches all) followed by <enter>.. "
  read i
  [ -n "$i" ] && cat $tmpDir/pkg_list0 | grep -E "$i" 2>/dev/null >$tmpDir/pkg_list || :
}


mk_list() {
  local pkg="" test=""
  : >$tmpDir/pkg_list0
  for pkg in $(find $appDataBkps -type d -maxdepth 1 \
    | sed "s:$appDataBkps::; s:/::")
  do
    case "$1" in
      not_installed)
        if ! grep -q $pkg $pkgList; then
          test=true
        else
          if grep $pkg /data/system/packages.xml | grep -q '/system/.*app/'; then
            if match_test inc $pkg && ! match_test exc $pkg; then
              test=false
            else
              test=true
            fi
          else
            if ! match_test exc $pkg; then
              if grep -q '^inc$' $config || match_test inc $pkg; then
                test=false
              else
                test=true
              fi
            else
              test=true
            fi
          fi
        fi;;
      installed) grep -q $pkg $pkgList && test=true || test=false;;
      all) test=true;;
    esac
    if $test; then
      echo "- $pkg"
      echo $pkg >>$tmpDir/pkg_list0
    fi
  done
}


restore() {
  local pkg="" o=""
  echo -e "\nRestoring $1.."
  for pkg in $(cat $tmpDir/pkg_list); do
    echo -n "- $pkg"
    if [ "x$1" = xapps+data ]; then
      if grep -q "$pkg" "$pkgList"; then
        pm install -r "$apkBkps/$pkg.apk" 1>/dev/null || :
      else
        pm install "$apkBkps/$pkg.apk" 1>/dev/null || :
      fi
    fi
    pm disable "$pkg" 1>/dev/null || :
    $rsync -Drt --del "$appDataBkps/$pkg/" /data/data/$pkg
   rm /data/data/$pkg/shared_prefs/com.google.android.gms.appid.xml 2>/dev/null || :
    echo
    restore_symlinks $appDataBkps/$pkg.lns
    o=$(grep "$pkg" "$pkgList" | awk '{print $2}')
    chown -R $o:$o /data/data/$pkg 2>/dev/null || :
    chmod -R 771 /data/data/$pkg 2>/dev/null || :
    pm enable "$pkg" 1>/dev/null
  done
  post_restore $1 $2
}


exit_or_not() {
  local o=""
  select o in Exit "Main menu"; do
    case $o in
      Exit) echo; exit 0;;
      "Main menu") wizard; break;;
     esac
  done
}


bkps_path() {
  local o="" bkpsDir=${apkBkps%/*}
  echo -e "Backups location..\n"
  select o in "$bkpsDir/ (default)" "$bkpsDir.old/" "<custom>" \
    "Return to main menu" Exit
  do
    case $o in
      "$bkpsDir.old/") bkpsDir=$bkpsDir.old;;
      "<custom>") echo -n "Custom path: "; read bkpsDir;;
      "Return to main menu") wizard;;
      Exit) echo; exit 0;;
    esac
    if [ -d $bkpsDir/apk -a -d $bkpsDir/appdata ]; then
      apkBkps=$bkpsDir/apk
      appDataBkps=$bkpsDir/appdata
    else
      echo -e "\n(!) Empty/invalid location! \n"
      bkps_path # recurse
    fi
    break
  done
  reset
  echo
}


wizard
